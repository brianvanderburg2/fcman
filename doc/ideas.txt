File Collection Manager 1.0 Ideas
=================================

Coding:
    Python, with wxPython as the GUI

Properties:
    core.description
    core.updated                Timestamp of when the file/dir was last updated
                                An item is updated when it is added or replaced.
                                Files are also updated if teh checksum is recalculated
                                and different from the last checksum.
    core.homepage               URL of the home page
    core.download               URL of the download page
    core.checksum               Calculated checksum in the form "type:value"
    core.notes                  Notes
    core.size                   Size of the fire
    core.timestamp              Modification timestamp
    core.group.0                Which group is this item a member of
    core.group.1                Multiple groups can be specified

Nodes:
    File <file name="...">
    Dir <dir name="...">
    Link <link name="..." linkto="...">

Syntax:

    <file name="myfile.tar.gx">
        <property name="core.description" value="..." />
        <property name="..." value="..." />
    </file>

    <dir name="projects">
        <property ...>
        <file ...>
        <dir ...>
        <link ...>
    </dir>
    

* Use a browser-like interface.

The program should use an interface that is much like a file browser. An
address bar/breadcrumbs bar can be used for navigation.  The view area
shows the items in the current view, both those in the collection and
those that are not.  A sidebar show multiple panes for various features
such as directory tree (both the collection and the real file system),
notes, dependencies, etc.

Each node in the file would have two functions:  Exists and IsTemp.
Exists is used to determine if the file itself actually exists.  IsTemp
is used to determine if the node is actually on the system but not part
of the collection to be saved.  When loading a given directory node, if
it does exist the contents of the directory will be checked.  Any item
that isn't currently in the collection gets added to the collection
with the temp flag.

Special overlay icons would exist to indicate various information about
the file.  One overlay would be for missing item (red minus), another for
new item (blue plus), another if the file seems to have changed (size or
timestamp issue, yellow pencil)

Each item has a popup menu that can be used to perform certain actions.
A properties action would open a properties dialog for editing various
pieces of information (the default double-click action).  This
information exists for files as well as for directories.  Some may
not exist for directories (such as checksum).

Both:
    Notes
    Packages/dependencies
    Groups
        If a directory is a member of a group, all files are considered members as well.
        Being a member of a subgroup causes membership with the group as well
            (if a node is a member of group a.b.c, then it is also a member of group a.b)

File only:
    Size
    Timestamp
    Checksum

Plugins
    The browser simply provides a container to work with.  Much of the actual
    functions would be implemented as plugins.  Plugins can hook into various
    routines to do their work.

    ContextMenuCreate hook.  When a user right-clicks on an item, the menu
    is built and the plugin context hook is called taking the item(s) selected.
    The plugin can insert the menu items desired.  If the user clicks on
    an item, the corresponding plugin will be called with the item id and
    item(s) selected.  At startup, the plugin would need to create all
    the ids used (wxNewId) so it would not regenerate each time.

    ContextMenuSelected hook.  

    PropertySheetCreate hook.

    QuickChecksStartHook
    QuickChecksItemHook
    QuickChecksEndHook

    PluginManager::Blah
        Call Blah on each plugin.  The plugin will have to decide whether
        it should act or not.  For example, if a menu item is selected
        that is not a standard item, then the plugin manager will pass
        the call to the ContextMenuSelected of each plugin.  Only the
        plugin with the menu id should actually act.

    Init (each plugin can initialize at startup)
    Load (called when opening a collection, Fets document root and file.
          can read information from document root and set file properties)
    Save (called when saving a collection.  Gets document root and file.
          can write information to document root from file properties.)
    Close (called when closing a collection)
    LoadItem (Called when loading an item during open.  Gets xml node and
          item node.  Can read xml and set item properties)
    SaveItem (Called when saving an item during save.  Gets xml node and
          item node.  Can write xml from item properties).

Arrangement:

    gui/
        __init__.py (contain some util functions like NewId)
        plugins/
            blah.py (contains gui components for blah plugin.  property sheet, etc)
    file/
        plugins/
            __init__.py (contains manager)
            blah.py
        collection/
            ...
        history/
            ...
        etc

    For multiple GUI toolkits, could have the gui as:

    gui/
        __init__.py (will select correct toolkit and import all names into gui)
            if gui == 'wx':
                from wxwidgets import *

        wxwidgets/
        gtk/
        qt/

    Then the base platform dependent parts of the plugins could just use gui:

    plugin create property sheet could just do:
        new gui.plugins.myplugin.propertysheet(...)


Collection Format:

<?xml version="1.0" encoding="utf-8"?>
<collection>
    <contents>
        <dir name="...">
            <file name="...">
            </file>
        </dir>
        <file name="...">
            <comment>...</comment>
            <property name="..." value="..." />
            or
            <property name="...">...</property> <!-- if no value attribute, use inner contents.</property>

            <!-- Common properties:
                module checksum:
                    filesize
                    checksum
                    checksumtime (time checksum was updated)
                dependencies
                    package
                    dependency

                Internally each property name is put in a list.  For items that only
                have one property, this means only one item.  If the same property is
                present more than once, such as package or dependency, the the matching
                list will have more than one item:

                node.properties['package'][0]
                node.properties['filesize'][0]

                node.getProperty(name, index=0)
                node.setProperty(name, value, index=0)
                
        </file>
    </contents>
</collection>


Collection:
    Collection classes
    Node
        getParent
        getPath
        getRealPath
        exists()
        isTemp()
        setMode() // MODE_COLLECTION, MODE_FILESYSTEM or both
        move(source, dest)
        rename(source, name)
        delete(source)
        File
        Directory
            update() // rescan and add temporary nodes as needed
            RootDirectory
