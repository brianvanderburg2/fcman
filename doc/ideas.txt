File Collection Manager 1.0 Ideas
=================================

Coding:
    wxPython, using wxAUI to give the user more control over laying out the window.

Properties:
    core.description
    core.updated                Timestamp of when the file/dir was last updated
                                An item is updated when it is added or replaced.
                                Files are also updated if teh checksum is recalculated
                                and different from the last checksum.
    core.homepage               URL of the home page
    core.download               URL of the download page
    core.checksum               Calculated checksum in the form "type:value"
    core.sigkey                 Trusted key fingerprint for the original files.
                                Downloaded files may be recompressed from gz to xz,
                                but this is the trusted key or keys for the original
                                signed file (.gz.sig)
    core.size                   Size of the file
    

* Use a browser-like interface.

The program should use an interface that is much like a file browser. An
address bar/breadcrumbs bar can be used for navigation.  The view area
shows the items in the current view, both those in the collection and
those that are not.  A sidebar show multiple panes for various features
such as directory tree (both the collection and the real file system),
notes, update checks, dependencies, etc.

Each node in the file would have two functions:  Exists and IsTemp.
Exists is used to determine if the file itself actually exists.  IsTemp
is used to determine if the node is actually on the system but not part
of the collection to be saved.  When loading a given directory node, if
it does exist the contents of the directory will be checked.  Any item
that isn't currently in the collection gets added to the collection
with the temp flag.

Special overlay icons would exist to indicate various information about
the file.  One overlay would be for missing item (red minus), another for
new item (blue plus), another if the file seems to have changed (size or
timestamp issue, yellow pencil)

Each item has a popup menu that can be used to perform certain actions.
A properties action would open a properties dialog for editing various
pieces of information (the default double-click action).  This
information exists for files as well as for directories.  Some may
not exist for directories (such as checksum).

Both:
    Notes
    Update checks
    Packages/dependencies
    Tags

File only:
    Size
    Timestamp
    Checksum

Extra:
    Last updated (the time the item was inserted/updated in the collection)


Search is provided by searching various pieces of information in the tree
of the collection.  A search processor would provide one type of data to
search for.  One or more processors can be specified in a search along
with the option for any or all to match for the search to be found.  The
search may specify to search the entire collection or just the current
directory and subdirectories, or if in a search already, the current
search contents.


Post-download scripts.
    An information structure would get passed to a python script.  The
    python script can then do what it needs, recompress, etc.  It could
    move the old file to a temp directoryand keep the new file in place.

Merge
    Files can be merged into the collection by specifying a source
    directory.  The directory is scanned for files and the program tries
    to guess where the files should go and also if the files should replace
    another file.  If the file should replace another file, the other file
    may be preserved in a history if it is enabled.

    Merge can also support directories if in the collection a directory is
    set to be the merge marker.  Then an engire directory is replaced and
    the old directory either kept as history or moved to a temp location.

    By default, only files are set as merge markers.

Tags
    Each file/directory can have associated tags.  Predefined tag sets can
    be created so that a set of tags can be created for a file/directory.
    Tags have a name=value form.

Keywords
    Each file/directory can have keywords to facilitate in searching.

Hint
    Each file/directory can have a hint that will appear in the browser
    interface along with the icon and filename.

Plugins
    The browser simply provides a container to work with.  Much of the actual
    functions would be implemented as plugins.  Plugins can hook into various
    routines to do their work.

    ContextMenuCreate hook.  When a user right-clicks on an item, the menu
    is built and the plugin context hook is called taking the item(s) selected.
    The plugin can insert the menu items desired.  If the user clicks on
    an item, the corresponding plugin will be called with the item id and
    item(s) selected.  At startup, the plugin would need to create all
    the ids used (wxNewId) so it would not regenerate each time.

    ContextMenuSelected hook.  

    PropertySheetCreate hook.

    QuickChecksStartHook
    QuickChecksItemHook
    QuickChecksEndHook

    PluginManager::Blah
        Call Blah on each plugin.  The plugin will have to decide whether
        it should act or not.  For example, if a menu item is selected
        that is not a standard item, then the plugin manager will pass
        the call to the ContextMenuSelected of each plugin.  Only the
        plugin with the menu id should actually act.

    Init (each plugin can initialize at startup)
    Load (called when opening a collection, Fets document root and file.
          can read information from document root and set file properties)
    Save (called when saving a collection.  Gets document root and file.
          can write information to document root from file properties.)
    Close (called when closing a collection)
    LoadItem (Called when loading an item during open.  Gets xml node and
          item node.  Can read xml and set item properties)
    SaveItem (Called when saving an item during save.  Gets xml node and
          item node.  Can write xml from item properties).

Arrangement:

    gui/
        __init__.py (contain some util functions like NewId)
        plugins/
            blah.py (contains gui components for blah plugin.  property sheet, etc)
    file/
        plugins/
            __init__.py (contains manager)
            blah.py
        collection/
            ...
        history/
            ...
        etc

    For multiple GUI toolkits, could have the gui as:

    gui/
        __init__.py (will select correct toolkit and import all names into gui)
            if gui == 'wx':
                from wxwidgets import *

        wxwidgets/
        gtk/
        qt/

    Then the base platform dependent parts of the plugins could just use gui:

    plugin create property sheet could just do:
        new gui.plugins.myplugin.propertysheet(...)


Collection Format:

<?xml version="1.0" encoding="utf-8"?>
<collection>
    <contents>
        <dir name="...">
            <file name="...">
            </file>
        </dir>
        <file name="...">
            <comment>...</comment>
            <property name="..." value="..." />
            or
            <property name="...">...</property> <!-- if no value attribute, use inner contents.</property>

            <!-- Common properties:
                module checksum:
                    filesize
                    checksum
                    checksumtime (time checksum was updated)
                dependencies
                    package
                    dependency

                Internally each property name is put in a list.  For items that only
                have one property, this means only one item.  If the same property is
                present more than once, such as package or dependency, the the matching
                list will have more than one item:

                node.properties['package'][0]
                node.properties['filesize'][0]

                node.getProperty(name, index=0)
                node.setProperty(name, value, index=0)
                
        </file>
    </contents>
</collection>


Collection:
    Collection classes
    Node
        getParent
        getPath
        getRealPath
        exists()
        isTemp()
        setMode() // MODE_COLLECTION, MODE_FILESYSTEM or both
        move(source, dest)
        rename(source, name)
        delete(source)
        File
        Directory
            update() // rescan and add temporary nodes as needed
            RootDirectory
